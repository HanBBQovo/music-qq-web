import { create } from "zustand";
import { persist, subscribeWithSelector } from "zustand/middleware";
import { toast } from "sonner";

import musicApi from "@/lib/api/client";
import { getAudioUrl } from "@/lib/utils/audio-url";
import { withErrorHandling } from "@/lib/utils/error";

import type { PlayerStoreState } from "./types";
import type { Song } from "@/lib/types/music";
import type { AudioQuality } from "@/lib/api/types";

import { createPlaybackSlice } from "./playback";
import { createPlaylistSlice } from "./playlist";
import { createQualitySlice } from "./quality";
import { createLyricSlice } from "./lyric";
import { createUISlice } from "./ui";
import { createNotificationSlice } from "../notification";
import { NotificationSlice } from "../notification";

export const usePlayerStore = create<PlayerStoreState>()(
  subscribeWithSelector(
    persist(
      (set, get, api) => ({
        ...createPlaybackSlice(set, get, api),
        ...createPlaylistSlice(set, get, api),
        ...createQualitySlice(set, get, api),
        ...createLyricSlice(set, get, api),
        ...createUISlice(set, get, api),
        ...createNotificationSlice(set, get, api),

        playSongList: async (songs, startIndex = 0) => {
          if (songs.length === 0) return;

          const actualStartIndex = startIndex < songs.length ? startIndex : 0;
          const startSong = songs[actualStartIndex];

          set({
            playlist: songs,
            currentSong: startSong,
            currentIndex: actualStartIndex,
            showPlayer: true,
          });

          await get().playSong(startSong);
        },

        playSong: async (song, quality) => {
          // 1. Á´ãÂç≥Êõ¥Êñ∞UIÔºåÊòæÁ§∫Ê≠åÊõ≤‰ø°ÊÅØÔºåÂáÜÂ§áÊí≠Êîæ
          const state = get();
          const useQuality = quality || state.currentQuality;
          let songIndex = state.playlist.findIndex(
            (s) => s.mid === song.mid || s.id === song.id
          );

          if (songIndex === -1) {
            const newPlaylist = [...state.playlist, song];
            songIndex = newPlaylist.length - 1;

            set({
              playlist: newPlaylist,
              currentSong: song,
              currentIndex: songIndex,
              currentQuality: useQuality,
              isPlaying: false,
              showPlayer: true,
              currentTime: 0,
              duration: song.duration || 0,
            });
          } else {
            set({
              currentSong: song,
              currentIndex: songIndex,
              currentQuality: useQuality,
              isPlaying: false,
              showPlayer: true,
              currentTime: 0,
              duration: song.duration || 0,
            });
          }

          // ‚òÖ Á´ãÂç≥ÂºÄÂßãËé∑ÂèñÊ≠åËØçÔºå‰∏éËé∑ÂèñÊí≠ÊîæURLÂπ∂Ë°å
          get().fetchKrcLyrics(true);

          // 2. ÂºÇÊ≠•Ëé∑ÂèñÊí≠ÊîæURLÂπ∂Â§ÑÁêÜÁªìÊûú
          await withErrorHandling({
            apiCall: () => getAudioUrl({ ...song, url: undefined }, useQuality),
            onSuccess: (url) => {
              const songWithUrl = { ...song, url };
              set((currentState) => {
                const newPlaylist = [...currentState.playlist];
                let currentIndex = currentState.playlist.findIndex(
                  (s) => s.mid === song.mid || s.id === song.id
                );
                if (currentIndex === -1) {
                  // ÁêÜËÆ∫‰∏ä‰∏ç‰ºöÂèëÁîüÔºåÂõ†‰∏∫ÂâçÈù¢Â∑≤ÁªèÂä†ËøõÂéª‰∫Ü
                  currentIndex = newPlaylist.length;
                  newPlaylist.push(songWithUrl);
                } else {
                  newPlaylist[currentIndex] = songWithUrl;
                }

                return {
                  playlist: newPlaylist,
                  currentSong: songWithUrl,
                  currentIndex: currentIndex,
                  isPlaying: true, // Ëé∑ÂèñÂà∞URLÂêéÊâçÁúüÊ≠£ÂºÄÂßãÊí≠Êîæ
                };
              });

              // get().fetchKrcLyrics(true); // ‚òÖ ‰ªéÊ≠§Â§ÑÁßªÂä®
            },
            onError: () => {
              // ÈîôËØØtoastÁî±withErrorHandlingÂ§ÑÁêÜ
              set({
                // ÂèØ‰ª•ÈÄâÊã©Âú®ËøôÈáåËÆæÁΩÆ‰∏Ä‰∏™ÈîôËØØÁä∂ÊÄÅÔºåÊàñËÄÖËÆ©Êí≠ÊîæÂô®ÂÅúÁïôÂú®isPlaing: falseÁöÑÁä∂ÊÄÅ
                isPlaying: false,
                krcLyricsError: "Êí≠ÊîæÂ§±Ë¥•ÔºåÊó†Ê≥ïËé∑ÂèñÊ≠åËØç",
              });
            },
            errorMessage: `Êí≠Êîæ ${song.title} Â§±Ë¥•`,
          });
        },

        switchQuality: async (quality: AudioQuality) => {
          const { currentSong, currentTime, isPlaying } = get();
          if (!currentSong) return;

          const savedTime = currentTime;
          const wasPlaying = isPlaying;

          set({ currentQuality: quality, isPlaying: false });

          await withErrorHandling({
            apiCall: async () => {
              const tempSong = { ...currentSong, url: undefined };
              const newUrl = await getAudioUrl(tempSong, quality);
              return { ...currentSong, url: newUrl };
            },
            onSuccess: (updatedSong) => {
              set({
                currentSong: updatedSong,
                currentTime: savedTime,
                isPlaying: false,
              });

              if (typeof window !== "undefined") {
                window.dispatchEvent(
                  new CustomEvent("quality-switch", {
                    detail: {
                      songId: currentSong.mid || currentSong.id,
                      targetTime: savedTime,
                      shouldResumePlayback: wasPlaying,
                    },
                  })
                );
              }

              toast.success(`Èü≥Ë¥®Â∑≤ÂàáÊç¢Âà∞${getQualityDisplayName(quality)}`, {
                duration: 2000,
              });
            },
            onError: (error) => {
              if (
                error.message.includes("ÈôçÁ∫ß") ||
                error.message.includes("fallback")
              ) {
                console.log(`‚ÑπÔ∏è Èü≥Ë¥®Ëá™Âä®ÈôçÁ∫ßÈÄöÁü•: ${error.message}`);
              } else {
                console.log("üîÑ ÂèëÁîüÈîôËØØÔºåÊÅ¢Â§çÂéüÊí≠ÊîæÁä∂ÊÄÅ");
                set({ isPlaying: wasPlaying });
                // toast Âú® withErrorHandling ‰∏≠Â§ÑÁêÜ
              }
            },
            errorMessage: `Èü≥Ë¥®ÂàáÊç¢Â§±Ë¥•`,
          });
        },

        fetchKrcLyrics: async (force = false) => {
          const { currentSong, krcLyrics, isKrcLyricsLoading } = get();

          if (
            !currentSong ||
            isKrcLyricsLoading ||
            (!force && krcLyrics && krcLyrics.length > 0)
          ) {
            return;
          }

          set({ isKrcLyricsLoading: true, krcLyricsError: null });

          await withErrorHandling({
            apiCall: () =>
              musicApi.getLyric({
                id: currentSong.id,
                mid: currentSong.mid,
                format: "krc",
              }),
            onSuccess: (res) => {
              if (res.data.krcData && res.data.krcData.lines) {
                const processedLines = res.data.krcData.lines.map((line) => ({
                  ...line,
                  words: line.words.map((word) => ({
                    ...word,
                    text: word.text === " " ? "\u00a0" : word.text,
                  })),
                }));
                set({ krcLyrics: processedLines, isKrcLyricsLoading: false });
              } else {
                set({
                  krcLyricsError: "Ê≤°ÊúâÂèØÁî®ÁöÑÈÄêÂ≠óÊ≠åËØç",
                  isKrcLyricsLoading: false,
                  krcLyrics: [],
                });
              }
            },
            onError: () => {
              set({
                krcLyricsError: "Êó†Ê≥ïÂä†ËΩΩÊ≠åËØç",
                isKrcLyricsLoading: false,
                krcLyrics: [],
              });
            },
            errorMessage: "Ëé∑ÂèñKRCÊ≠åËØçÂ§±Ë¥•",
            showToast: false,
          });
        },
      }),
      {
        name: "music-player-storage",
        partialize: (state) => ({
          volume: state.volume,
          playMode: state.playMode,
          currentQuality: state.currentQuality,
          playlist: state.playlist,
          currentIndex: state.currentIndex,
          currentSong: state.currentSong,
          qualitySizes: state.qualitySizes,
          availableQualities: state.availableQualities,
          recommendedQuality: state.recommendedQuality,
        }),
      }
    )
  )
);

if (typeof window !== "undefined") {
  window.addEventListener("quality-info-updated", (event: any) => {
    const { songId, qualityInfo } = event.detail;

    const state = usePlayerStore.getState();
    const currentSong = state.currentSong;
    if (!currentSong) return;

    const currentIdentifier = currentSong.mid || currentSong.id;
    if (currentIdentifier === songId) {
      usePlayerStore.setState({
        availableQualities: qualityInfo.availableQualities,
        qualitySizes: qualityInfo.qualitySizes,
        recommendedQuality: qualityInfo.recommendedQuality,
      });
    }
  });

  window.addEventListener("quality-fallback", (event: any) => {
    const { songId, actualQuality, requestedQuality, fallbackReason } =
      event.detail;

    const state = usePlayerStore.getState();
    const currentSong = state.currentSong;

    if (!currentSong) return;

    const currentIdentifier = currentSong.mid || currentSong.id;
    if (currentIdentifier === songId) {
      usePlayerStore.setState({ currentQuality: actualQuality });

      const cleanReason = cleanFallbackReason(fallbackReason);

      toast.warning(
        `Èü≥Ë¥®Â∑≤Ëá™Âä®ÈôçÁ∫ßÔºö${getQualityDisplayName(
          requestedQuality
        )} ‚Üí ${getQualityDisplayName(actualQuality)}`,
        {
          description: cleanReason,
          duration: 3000,
        }
      );
    }
  });
}

function getQualityDisplayName(quality: string): string {
  switch (quality) {
    case "128":
      return "Ê†áÂáÜÈü≥Ë¥®";
    case "320":
      return "È´òÂìÅÈü≥Ë¥®";
    case "flac":
      return "Êó†ÊçüÈü≥Ë¥®";
    case "ATMOS_2":
      return "ËáªÂìÅÂÖ®ÊôØÂ£∞2.0";
    case "ATMOS_51":
      return "ËáªÂìÅÈü≥Ë¥®2.0";
    case "MASTER":
      return "ËáªÂìÅÊØçÂ∏¶2.0";
    default:
      return quality;
  }
}

function cleanFallbackReason(reason: string | null): string {
  if (!reason) return "ËØ∑Ê±ÇÁöÑÈü≥Ë¥®‰∏çÂèØÁî®";

  if (reason.length > 50 && /^[A-Za-z0-9+/]+=*$/.test(reason)) {
    try {
      const decoded = atob(reason);
      try {
        const utf8Decoded = decodeURIComponent(escape(decoded));
        if (utf8Decoded && utf8Decoded.length > 0 && utf8Decoded !== decoded) {
          reason = utf8Decoded;
        } else {
          if (decoded && /^[\x20-\x7E\s]*$/.test(decoded)) {
            reason = decoded;
          } else {
            return "Èü≥Ë¥®ËµÑÊ∫ê‰∏çÂèØÁî®ÔºåÂ∑≤Ëá™Âä®ÈôçÁ∫ß";
          }
        }
      } catch (utf8Error) {
        if (decoded && /^[\x20-\x7E\s]*$/.test(decoded)) {
          reason = decoded;
        } else {
          return "Èü≥Ë¥®ËµÑÊ∫ê‰∏çÂèØÁî®ÔºåÂ∑≤Ëá™Âä®ÈôçÁ∫ß";
        }
      }
    } catch (e) {
      return "Èü≥Ë¥®ËµÑÊ∫ê‰∏çÂèØÁî®ÔºåÂ∑≤Ëá™Âä®ÈôçÁ∫ß";
    }
  }

  let cleaned = reason
    .replace(/&#\d+;/g, "")
    .replace(/&[^;]+;/g, "")
    .replace(/<[^>]*>/g, "")
    .replace(/[\x00-\x1F\x7F-\x9F]/g, "")
    .trim();

  if (cleaned.length > 100) {
    cleaned = cleaned.substring(0, 97) + "...";
  }

  if (!cleaned || cleaned.length < 3) {
    return "Èü≥Ë¥®ËµÑÊ∫ê‰∏çÂèØÁî®ÔºåÂ∑≤Ëá™Âä®ÈôçÁ∫ß";
  }

  return cleaned;
}
